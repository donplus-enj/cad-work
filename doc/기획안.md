# CAD-Work 프로젝트 기획서

**버전**: 2.0  
**최종 수정일**: 2025-10-19  
**작성자**: CAD-Work 프로젝트 팀

---

## 1. 프로젝트 개요

### 1.1 프로젝트명
**CAD-Work**: DXF 파일 치수/주석 관리 시스템

### 1.2 프로젝트 목적
2D CAD 도면 파일(DXF 포맷)에서 치수표기(Dimension)와 주석표기(Annotation)를 자동으로 추출, 분석, 수정할 수 있는 Python 기반 도구를 개발하여 CAD 도면의 품질 관리 및 유지보수 효율성을 향상시킨다.

### 1.3 프로젝트 범위
- **대상 파일 형식**: DXF (Drawing Exchange Format)
- **주요 처리 대상**: 치수표기(Dimension), 주석표기(Annotation), 지시선(Leader)
- **개발 언어**: Python
- **개발 모듈**: 3개 (분석, 삭제, 추가)

---

## 2. 핵심 개념 정의

### 2.1 용어 정의

| 용어 | 정의 |
|------|------|
| **치수표기(Dimension)** | 도면상의 길이, 각도 등을 나타내는 수치 정보 |
| **주석표기(Annotation)** | 도면에 대한 설명, 참고사항 등의 텍스트 정보 |
| **비형상정보(Non-geometry)** | 치수표기(Dimension)와 주석표기(Annotation)를 통칭하는 용어 |
| **지시선(Leader)** | 치수/주석이 가리키는 대상을 연결하는 선 |
| **지시화살표선(Leader-arrow-line)** | Leader/Ex-leaders 선들 중, 치수/주석이 의미하는 위치를 가리키는 화살표가 붙은 지시선 |
| **지시경계선(Leader-boundary-line)** | Leader/Ex-leaders 선들 중, 치수/주석이 적용되는 범위의 경계를 나타내는 수직선 |
| **Ex-leaders** | DXF에서 leader로 분류되지 않았지만 실제로는 지시선 역할을 하는 lines |

### 2.2 화살표(Arrow) 정의

#### 2.2.1 화살표의 구조적 정의

화살표는 **주축선(Main Shaft)**과 **화살촉(Arrowhead)**으로 구성된다.

```
화살표 구성:
    화살표 = 주축선 + 화살촉

    주축선 (Shaft): 긴 직선 (LINE 엔티티)
    화살촉 (Arrowhead): 주축선 끝에 붙은 2개의 짧은 선분으로 구성된 V자 형태
```

**시각적 표현:**
```
        left_barb
           ╱
    ──────●  ← tip_point (화살표 끝점)
     shaft ╲
        right_barb
```

#### 2.2.2 화살표 구성요소 상세

```python
class ArrowComponents:
    """화살표 구성요소"""
    
    # 주축선 (Shaft Line)
    shaft_start: Point      # 화살표 시작점 (꼬리 부분)
    shaft_end: Point        # 화살표 끝점 (= tip_point)
    
    # 화살촉 (Arrowhead - 2개 선분)
    left_barb_start: Point  # 왼쪽 화살촉 시작점 (= tip_point)
    left_barb_end: Point    # 왼쪽 화살촉 끝점
    
    right_barb_start: Point # 오른쪽 화살촉 시작점 (= tip_point)
    right_barb_end: Point   # 오른쪽 화살촉 끝점
    
    # 핵심 속성
    tip_point: Point        # 화살촉이 만나는 점 (= shaft_end)
    direction: Vector       # 화살표가 가리키는 방향
```

#### 2.2.3 화살표 판별 기준 (수학적 조건)

화살표로 인정되기 위해서는 다음 5가지 조건을 모두 만족해야 한다:

##### **조건 1: 끝점 일치 (Tip Point Convergence)**
```python
# 주축선의 끝점과 두 화살촉의 시작점이 일치해야 함
tolerance = 0.1  # mm (설정 가능)

distance(shaft.end_point, left_barb.start_point) < tolerance AND
distance(shaft.end_point, right_barb.start_point) < tolerance
```

##### **조건 2: 화살촉 길이 (Barb Length)**
```python
# 화살촉 선분의 길이가 설정 범위 내에 있어야 함
arrow_length_min = 2.0  # mm (설정 가능)
arrow_length_max = 5.0  # mm (설정 가능)

arrow_length_min <= length(left_barb) <= arrow_length_max AND
arrow_length_min <= length(right_barb) <= arrow_length_max
```

##### **조건 3: 화살촉 각도 (Barb Angle)**
```python
# 각 화살촉이 주축선과 이루는 각도가 범위 내에 있어야 함
arrow_angle_min = 15.0  # 도 (설정 가능)
arrow_angle_max = 45.0  # 도 (설정 가능)

angle1 = angle_between(shaft_line, left_barb)
angle2 = angle_between(shaft_line, right_barb)

arrow_angle_min <= angle1 <= arrow_angle_max AND
arrow_angle_min <= angle2 <= arrow_angle_max
```

##### **조건 4: 대칭성 (Symmetry) - 선택사항**
```python
# 두 화살촉이 주축선을 중심으로 대칭인지 확인 (선택적 조건)
symmetry_tolerance = 5.0  # 도 (설정 가능)

angle_diff = abs(angle1 - angle2)
angle_diff <= symmetry_tolerance
```

##### **조건 5: 방향성 (Direction)**
```python
# 화살촉이 주축선 방향의 반대쪽(뒤로)을 향해야 함
shaft_direction = direction_vector(shaft_line)
left_barb_direction = direction_vector(left_barb)
right_barb_direction = direction_vector(right_barb)

# 내적이 음수여야 함 (반대 방향)
dot_product(shaft_direction, left_barb_direction) < 0 AND
dot_product(shaft_direction, right_barb_direction) < 0
```

#### 2.2.4 각도 계산 정의

```python
def angle_between(line1, line2) -> float:
    """
    두 선분 사이의 각도 계산
    
    Returns:
        각도 (0° ~ 180°, 도 단위)
    """
    # 방향 벡터
    v1 = (line1.end.x - line1.start.x, line1.end.y - line1.start.y)
    v2 = (line2.end.x - line2.start.x, line2.end.y - line2.start.y)
    
    # 내적을 이용한 각도 계산
    dot = v1[0]*v2[0] + v1[1]*v2[1]
    mag1 = sqrt(v1[0]**2 + v1[1]**2)
    mag2 = sqrt(v2[0]**2 + v2[1]**2)
    
    cos_angle = dot / (mag1 * mag2)
    cos_angle = max(-1.0, min(1.0, cos_angle))  # 부동소수점 오차 보정
    
    angle_rad = acos(cos_angle)
    angle_deg = degrees(angle_rad)
    
    return angle_deg
```

#### 2.2.5 화살표 설정 파라미터

```python
ARROW_DETECTION_CONFIG = {
    # 화살촉 길이 범위
    'arrow_length_min': 2.0,      # mm - 이보다 짧으면 노이즈로 간주
    'arrow_length_max': 5.0,      # mm - 이보다 길면 일반 선분으로 간주
    
    # 화살촉 각도 범위
    'arrow_angle_min': 15.0,      # 도 - 너무 예각이면 화살표 아님
    'arrow_angle_max': 45.0,      # 도 - 너무 둔각이면 화살표 아님
    
    # 끝점 일치 허용 오차
    'tip_point_tolerance': 0.1,   # mm - 화살촉과 주축선 끝점의 최대 간격
    
    # 대칭성 검사 (선택)
    'check_symmetry': False,      # True이면 좌우 대칭 화살표만 인정
    'symmetry_tolerance': 5.0,    # 도 - 좌우 각도 차이 허용 범위
    
    # 화살촉 길이 비율 (선택)
    'check_barb_ratio': False,    # True이면 화살촉 길이 비율 검사
    'barb_ratio_min': 0.5,        # 두 화살촉 길이 비율의 최소값
    'barb_ratio_max': 2.0,        # 두 화살촉 길이 비율의 최대값
}
```

#### 2.2.6 화살표 유형 분류

본 프로젝트에서 지원하는 화살표 유형:

| 유형 | 설명 | 구현 우선순위 | 비고 |
|------|------|--------------|------|
| **열린 화살표** | 2개 선분으로 구성된 V자 형태 | Phase 1 | 기본 구현 대상 |
| **대칭 화살표** | 좌우 각도가 동일한 화살표 | Phase 1 | 기본 구현 대상 |
| **비대칭 화살표** | 좌우 각도가 다른 화살표 | Phase 1.5 | 확장 구현 |
| **블록 화살표** | INSERT 엔티티로 정의된 화살표 | Phase 1.5 | 확장 구현 |
| **채워진 화살표** | SOLID/HATCH로 표현된 화살표 | Phase 2 | 고급 기능 |
| **점 화살표** | POINT/작은 CIRCLE로 표현 | Phase 2 | 고급 기능 |

**Phase 1 범위:**
- 열린/닫힌 화살표 (LINE 기반)
- 대칭 화살표

### 2.3 DXF 엔티티 분류

```
DXF 파일 구성요소
├── 도형 요소 (Geometry)
│   ├── LINE (직선)
│   ├── CIRCLE (원)
│   ├── ARC (호)
│   ├── POLYLINE (폴리선)
│   └── 기타 도형
│
├── 비형상 요소 (Non-geometry)
│   ├── TEXT (단순 텍스트)
│   ├── MTEXT (다중 텍스트)
│   ├── DIMENSION (치수)
│   └── LEADER (지시선)
│
└── 보조 요소
    └── Ex-leaders (도형으로 분류되나 실제 지시선)
```

---

## 3. 시스템 아키텍처

### 3.1 전체 구조

```
CAD-Work 프로젝트
│
├── Module 1: chk_dimension.py (분석 모듈)
│   ├── DXF 파일 구조 분석
│   ├── 엔티티 분류 및 추출
│   ├── 화살표 패턴 탐지
│   ├── 지시선 탐지 및 매칭
│   └── 분석 결과 문서화
│
├── Module 2: del_dimension.py (삭제 모듈)
│   ├── 치수/주석 엔티티 식별
│   ├── 해당 엔티티 삭제
│   └── 결과 DXF 파일 저장 (output.dxf)
│
└── Module 3: add_dimension.py (추가 모듈)
    ├── CSV 파일에서 추가 정보 로드
    ├── 치수/주석 엔티티 생성
    └── DXF 파일에 추가
```

### 3.2 데이터 흐름

```
[입력 DXF] 
    ↓
[chk_dimension.py] → [분석 보고서 (텍스트/JSON)]
    ↓
[del_dimension.py] → [output.dxf (치수/주석 제거)]
    ↓
[add_dimension.py] + [CSV 정의 파일] → [최종 DXF (치수/주석 추가)]
```

---

## 4. Module 1: chk_dimension.py 상세 설계

### 4.1 기능 개요
DXF 파일을 분석하여 치수/주석 관련 모든 정보를 추출하고 문서화한다.

### 4.2 주요 기능

#### 4.2.1 Layer 구조 분석
```python
# 기능: DXF 파일의 모든 레이어 추출 및 분류
출력 정보:
- 레이어 이름 목록
- 각 레이어별 포함 엔티티 유형
- 치수/주석 전용 레이어 식별
```

#### 4.2.2 엔티티 분류
```python
# 기능: DXF 파일의 모든 엔티티를 유형별로 분류
분류 카테고리:
- LINE (직선)
- CIRCLE (원)
- ARC (호)
- POLYLINE (폴리선)
- TEXT (텍스트)
- MTEXT (다중 텍스트)
- DIMENSION (치수)
- LEADER (지시선)
- INSERT (블록 삽입)
- SPLINE (스플라인)
- ELLIPSE (타원)
- HATCH (해치)
- 기타 (분류되지 않은 엔티티)
```

#### 4.2.3 치수/주석 1차 식별
```python
# 기능: 명확한 치수/주석 엔티티 식별
대상 엔티티:
1. TEXT - 모든 TEXT 엔티티
2. MTEXT - 모든 MTEXT 엔티티
3. LEADER - 모든 LEADER 엔티티

추출 정보:
- 엔티티 핸들(고유 ID)
- 위치 좌표 (x, y)
- 텍스트 내용 (TEXT/MTEXT의 경우)
- 레이어 이름
- 스타일 정보
```

#### 4.2.4 화살표 탐지 알고리즘

##### 4.2.4.1 화살표 탐지 전체 흐름

```python
def detect_arrows_in_drawing(lines, config):
    """
    도면에서 모든 화살표 탐지
    
    알고리즘:
    1. LINE 엔티티를 길이 기준으로 분류
    2. 긴 선분(주축선 후보)의 양 끝점에서 화살표 검사
    3. 발견된 화살표 정보 수집
    
    Args:
        lines: 모든 LINE 엔티티 리스트
        config: 화살표 탐지 설정
    
    Returns:
        arrows: 탐지된 Arrow 객체 리스트
    """
    
    arrows = []
    
    # Step 1: 모든 LINE을 길이 기준으로 분류
    long_lines = []   # 주축선 후보 (길이 > arrow_length_max)
    short_lines = []  # 화살촉 후보 (길이 <= arrow_length_max)
    
    for line in lines:
        line_length = length(line)
        if line_length > config['arrow_length_max']:
            long_lines.append(line)
        else:
            short_lines.append(line)
    
    # Step 2: 각 긴 선분(주축선 후보)의 양 끝점에서 화살표 검사
    for shaft in long_lines:
        # 주축선의 시작점에서 화살표 확인
        arrow = check_arrow_at_endpoint(
            shaft, 
            shaft.start_point, 
            short_lines, 
            config,
            reverse=True  # 시작점 방향은 역방향
        )
        if arrow:
            arrows.append(arrow)
        
        # 주축선의 끝점에서 화살표 확인
        arrow = check_arrow_at_endpoint(
            shaft, 
            shaft.end_point, 
            short_lines, 
            config,
            reverse=False
        )
        if arrow:
            arrows.append(arrow)
    
    return arrows
```

##### 4.2.4.2 특정 점에서 화살표 확인

```python
def check_arrow_at_endpoint(shaft_line, tip_point, candidate_lines, 
                            config, reverse=False):
    """
    특정 점에서 화살표 패턴 확인
    
    Args:
        shaft_line: 주축선 후보
        tip_point: 화살표 끝점 후보
        candidate_lines: 화살촉 후보 선분들
        config: 설정
        reverse: 시작점 방향인 경우 True
    
    Returns:
        Arrow 객체 또는 None
    """
    
    # Step 1: tip_point 근처의 선분 찾기 (조건 1: 끝점 일치)
    nearby_lines = []
    tolerance = config['tip_point_tolerance']
    
    for line in candidate_lines:
        if distance(line.start_point, tip_point) < tolerance:
            nearby_lines.append(line)
    
    # Step 2: 최소 2개의 선분 필요
    if len(nearby_lines) < 2:
        return None
    
    # Step 3: 가능한 모든 2개 조합 검사
    from itertools import combinations
    
    for barb1, barb2 in combinations(nearby_lines, 2):
        # 방향 조정 (시작점인 경우 선분을 뒤집음)
        test_shaft = shaft_line
        if reverse:
            test_shaft = reverse_line(shaft_line)
        
        # 화살표 패턴 검사 (조건 2~5)
        if is_arrow_pattern(test_shaft, barb1, barb2, config):
            return Arrow(
                shaft=test_shaft,
                left_barb=barb1,
                right_barb=barb2,
                tip_point=tip_point,
                direction='start' if reverse else 'end'
            )
    
    return None
```

##### 4.2.4.3 화살표 패턴 판정

```python
def is_arrow_pattern(shaft_line, barb1, barb2, config) -> bool:
    """
    화살표 패턴 판별 (5가지 조건 검사)
    
    조건 1: 끝점 일치 (이미 check_arrow_at_endpoint에서 확인됨)
    조건 2: 화살촉 길이
    조건 3: 화살촉 각도
    조건 4: 대칭성 (선택)
    조건 5: 방향성
    """
    
    # === 조건 2: 화살촉 길이 ===
    barb1_length = length(barb1)
    barb2_length = length(barb2)
    
    min_len = config['arrow_length_min']
    max_len = config['arrow_length_max']
    
    if not (min_len <= barb1_length <= max_len and
            min_len <= barb2_length <= max_len):
        return False
    
    # === 조건 3: 화살촉 각도 ===
    angle1 = angle_between(shaft_line, barb1)
    angle2 = angle_between(shaft_line, barb2)
    
    min_angle = config['arrow_angle_min']
    max_angle = config['arrow_angle_max']
    
    if not (min_angle <= angle1 <= max_angle and
            min_angle <= angle2 <= max_angle):
        return False
    
    # === 조건 4: 대칭성 (선택) ===
    if config.get('check_symmetry', False):
        angle_diff = abs(angle1 - angle2)
        symmetry_tolerance = config.get('symmetry_tolerance', 5.0)
        
        if angle_diff > symmetry_tolerance:
            return False
    
    # === 조건 5: 방향성 ===
    shaft_direction = direction_vector(shaft_line)
    barb1_direction = direction_vector(barb1)
    barb2_direction = direction_vector(barb2)
    
    # 화살촉이 주축선 방향과 반대를 향해야 함
    if not (dot_product(shaft_direction, barb1_direction) < 0 and
            dot_product(shaft_direction, barb2_direction) < 0):
        return False
    
    return True
```

#### 4.2.5 지시화살표선 탐지 알고리즘

```python
# 설정 가능한 파라미터
CONFIG = {
    'ARROW_DETECTION': {
        'arrow_length_min': 2.0,      # 화살표 최소 길이 (mm)
        'arrow_length_max': 5.0,      # 화살표 최대 길이 (mm)
        'arrow_angle_min': 15.0,      # 화살표 각도 최소 (도)
        'arrow_angle_max': 45.0,      # 화살표 각도 최대 (도)
        'tip_point_tolerance': 0.1,   # 끝점 일치 허용 오차 (mm)
        'check_symmetry': False,      # 대칭성 검사 여부
        'symmetry_tolerance': 5.0,    # 대칭 허용 오차 (도)
    },
    'ARROW_CONNECTED_LINE': {
        'max_gap': 3.0,                # 직선 연결 최대 간격 (mm)
        'angle_tolerance': 5.0,        # 각도 허용 오차 (도)
    },
    'LEADER_ARROW_MATCHING': {
        'max_distance': 10.0,          # 텍스트 매칭 최대 거리 (mm)
    }
}

# 알고리즘 단계
1. 화살표 패턴 탐지 (위의 detect_arrows_in_drawing 함수 사용)
   
2. 지시화살표선 위치 결정
   Case A: 한쪽 끝만 화살표
   → 위치 = 화살표 반대쪽 끝점 (shaft.start_point)
   
   Case B: 양쪽 끝 모두 화살표
   → 위치 = 직선 중점
   
   Case C: 2개 직선 연결형
   → 화살표 직선 + 연결 직선
   → 위치 = 연결 직선의 끝점 (화살표 반대쪽)

3. 텍스트 매칭
   - 각 지시화살표선 위치에서 가장 가까운 TEXT/MTEXT 찾기
   - 최대 매칭 거리 이내인 경우에만 매칭
   - 하나의 텍스트에 여러 지시화살표선 매칭 가능
```

#### 4.2.6 연결된 직선 탐지 (Case C)

```python
def find_connected_line(arrow_line, candidate_lines, config):
    """
    화살표가 붙은 직선에 연결된 다른 직선 찾기
    
    Args:
        arrow_line: 화살표가 붙은 직선
        candidate_lines: 연결 후보 직선들
        config: 설정
    
    Returns:
        연결된 직선 또는 None
    """
    
    # 화살표가 붙지 않은 쪽 끝점
    connection_point = arrow_line.start_point  # 화살표가 end에 있다고 가정
    
    max_gap = config['max_gap']
    angle_tolerance = config['angle_tolerance']
    
    for candidate in candidate_lines:
        # 거리 검사
        dist_to_start = distance(connection_point, candidate.start_point)
        dist_to_end = distance(connection_point, candidate.end_point)
        
        if min(dist_to_start, dist_to_end) > max_gap:
            continue
        
        # 각도 검사 (연결되려면 각도가 비슷해야 함)
        angle_diff = abs(angle_between(arrow_line, candidate))
        
        if angle_diff < angle_tolerance or abs(180 - angle_diff) < angle_tolerance:
            return candidate
    
    return None
```

#### 4.2.7 지시경계선 탐지 알고리즘

```python
# 설정 가능한 파라미터
CONFIG['LEADER_BOUNDARY_MATCHING'] = {
    'max_distance_to_arrow': 5.0,     # 화살표와 최대 거리 (mm)
    'perpendicular_angle_min': 89.5,  # 직각 최소 각도 (도)
    'perpendicular_angle_max': 90.5,  # 직각 최대 각도 (도)
}

# 알고리즘 단계
1. 전제조건
   - 지시화살표선이 먼저 식별되어 있어야 함

2. 후보 직선 선정
   - LINE 및 LEADER 중 지시화살표선이 아닌 것
   
3. 지시경계선 판정 조건
   조건 1: 화살표 위치와의 거리 < max_distance_to_arrow
   조건 2: 화살표 직선과의 각도 ≈ 90° (오차 범위 내)
   
4. 특수 케이스 처리
   - 양쪽 화살표형 지시선 → 최대 2개의 지시경계선 가능
```

### 4.3 출력 형식

#### 4.3.1 분석 보고서 구조
```
DXF 파일 분석 보고서
===================

[1. 파일 정보]
- 파일명: example.dxf
- 파일 크기: 1.2 MB
- DXF 버전: AC1027
- 분석 일시: 2025-10-19 14:30:00

[2. 레이어 구조]
레이어명          | 엔티티 수 | 주요 엔티티 유형
-----------------+-----------+------------------
0 (기본)         | 523       | LINE, CIRCLE, ARC
DIMENSION        | 45        | TEXT, LEADER, LINE
ANNOTATION       | 12        | MTEXT, LEADER

[3. 엔티티 분류 통계]
엔티티 유형      | 총 개수   | 레이어별 분포
-----------------+-----------+------------------
LINE             | 350       | 0: 320, DIMENSION: 30
CIRCLE           | 45        | 0: 45
TEXT             | 38        | DIMENSION: 38
MTEXT            | 12        | ANNOTATION: 12
LEADER           | 15        | DIMENSION: 15
...

[4. 화살표 탐지 결과]
총 탐지된 화살표: 25개

4.1 화살표 상세 정보
----------------------------------------
ID: ARW001
- 주축선: (230.0, 180.0) → (255.0, 180.0)
- 왼쪽 화살촉: (255.0, 180.0) → (252.0, 182.0)
- 오른쪽 화살촉: (255.0, 180.0) → (252.0, 178.0)
- 화살촉 길이: 3.2mm, 3.2mm
- 화살촉 각도: 32.5°, 32.5° (대칭)
- 화살표 방향: 끝점
- 검증 상태: ✓ 모든 조건 만족

[5. 치수/주석 상세 분석]

5.1 텍스트 엔티티 (TEXT)
----------------------------------------
ID: E001
- 내용: "100.0"
- 위치: (250.5, 180.3)
- 레이어: DIMENSION
- 매칭된 지시화살표선: A001, A002

ID: E002
- 내용: "R50"
- 위치: (300.0, 200.0)
- 레이어: DIMENSION
- 매칭된 지시화살표선: 없음 ⚠️

...

5.2 지시화살표선 (Arrow Leaders)
----------------------------------------
ID: A001
- 유형: 단일 직선, 한쪽 화살표
- 화살표 위치: (240.0, 180.0)
- 지시 위치: (255.0, 180.5)
- 길이: 15.0 mm
- 기반 화살표: ARW001
- 매칭된 텍스트: E001 ("100.0")
- 매칭된 지시경계선: B001

ID: A002
- 유형: 2개 직선 연결, 한쪽 화살표
- 화살표 위치: (238.0, 175.0)
- 지시 위치: (255.5, 180.0)
- 전체 길이: 20.5 mm
- 기반 화살표: ARW002
- 매칭된 텍스트: E001 ("100.0")
- 매칭된 지시경계선: 없음

...

5.3 지시경계선 (Boundary Lines)
----------------------------------------
ID: B001
- 위치: (240.0, 165.0) → (240.0, 195.0)
- 길이: 30.0 mm
- 관련 지시화살표선: A001
- 화살표와의 거리: 3.2 mm
- 수직 각도: 90.0°

...

[6. 검출된 문제점]
⚠️ 매칭되지 않은 텍스트: 3개 (E002, E015, E023)
⚠️ 텍스트가 없는 지시화살표선: 2개 (A008, A012)
⚠️ 지시경계선이 없는 지시화살표선: 5개
⚠️ 화살표 조건 미달: 3개 (각도 범위 초과)

[7. Ex-leaders 탐지 결과]
총 Ex-leaders 발견: 8개
(지시선으로 분류되지 않았으나 지시선 역할을 하는 LINE)

ID: EX001
- 원본 엔티티: LINE
- 레이어: 0
- 역할: 지시화살표선
- 매칭 텍스트: E005

...
```

### 4.4 기술적 고려사항

#### 4.4.1 사용 라이브러리
```python
# 주요 라이브러리
- ezdxf: DXF 파일 읽기/쓰기
- numpy: 기하학 계산 (거리, 각도)
- pandas: 데이터 정리 및 통계 (선택사항)
```

#### 4.4.2 성능 최적화
```python
# 대용량 DXF 파일 처리를 위한 고려사항
1. 공간 인덱싱 (Spatial Indexing)
   - R-tree 또는 KD-tree 사용하여 가까운 엔티티 빠르게 검색
   - 화살표 탐지 시 nearby_lines 검색에 활용

2. 청크 단위 처리
   - 메모리 효율을 위해 레이어 또는 영역별로 분할 처리

3. 캐싱
   - 반복 계산되는 값 (거리, 각도) 캐싱
   - 이미 검사한 선분 조합은 건너뛰기
```

#### 4.4.3 유틸리티 함수

```python
# 기하학 계산 함수
def length(line):
    """선분의 길이"""
    dx = line.end.x - line.start.x
    dy = line.end.y - line.start.y
    return math.sqrt(dx*dx + dy*dy)

def distance(point1, point2):
    """두 점 사이의 거리"""
    dx = point2.x - point1.x
    dy = point2.y - point1.y
    return math.sqrt(dx*dx + dy*dy)

def direction_vector(line):
    """선분의 방향 벡터"""
    return (line.end.x - line.start.x, 
            line.end.y - line.start.y)

def dot_product(v1, v2):
    """벡터 내적"""
    return v1[0]*v2[0] + v1[1]*v2[1]

def reverse_line(line):
    """선분의 방향을 뒤집음"""
    return Line(start=line.end, end=line.start)
```

---

## 5. Module 2: del_dimension.py 상세 설계

### 5.1 기능 개요
DXF 파일에서 모든 치수/주석 관련 엔티티를 제거하고 순수 도형만 남긴 output.dxf 파일을 생성한다.

### 5.2 삭제 대상 엔티티
```python
DELETE_TARGETS = [
    'TEXT',           # 모든 텍스트
    'MTEXT',          # 다중 텍스트
    'LEADER',         # 지시선
    'DIMENSION',      # 치수 (DXF 네이티브 치수)
    # Ex-leaders는 별도 판정 로직 필요 (분석 결과 기반)
    # 화살표 구성 LINE들도 삭제 대상
]
```

### 5.3 처리 흐름
```
1. DXF 파일 로드
   ↓
2. chk_dimension.py의 분석 결과 활용
   ↓
3. 삭제 대상 엔티티 식별
   - 기본 삭제 대상 (TEXT, MTEXT, LEADER, DIMENSION)
   - Ex-leaders (분석 결과 기반)
   - 화살표 구성 LINE (분석 결과 기반)
   ↓
4. 엔티티 삭제 실행
   ↓
5. output.dxf로 저장
   ↓
6. 삭제 보고서 생성
```

### 5.4 출력
```
- output.dxf: 치수/주석이 제거된 DXF 파일
- deletion_report.txt: 삭제 내역 보고서
  - 삭제된 엔티티 개수
  - 엔티티 유형별 삭제 통계
  - 화살표 삭제 통계
  - 보존된 엔티티 통계
```

---

## 6. Module 3: add_dimension.py 상세 설계

### 6.1 기능 개요
CSV 파일에 정의된 치수/주석 정보를 읽어 DXF 파일에 추가한다.

### 6.2 CSV 입력 형식
```csv
type,content,x,y,layer,arrow_x1,arrow_y1,arrow_x2,arrow_y2,boundary_x1,boundary_y1,boundary_x2,boundary_y2
TEXT,100.0,250.5,180.3,DIMENSION,240.0,180.0,,,240.0,165.0,240.0,195.0
MTEXT,주의사항: 용접부,300.0,250.0,ANNOTATION,290.0,245.0,,,,,
TEXT,R50,350.0,200.0,DIMENSION,340.0,200.0,360.0,200.0,340.0,190.0,340.0,210.0
```

**CSV 컬럼 설명:**
- `type`: 엔티티 유형 (TEXT, MTEXT)
- `content`: 표시할 텍스트 내용
- `x, y`: 텍스트 위치 좌표
- `layer`: 배치할 레이어 이름
- `arrow_x1, arrow_y1`: 첫 번째 화살표 위치 (선택사항)
- `arrow_x2, arrow_y2`: 두 번째 화살표 위치 (선택사항, 양쪽 화살표)
- `boundary_x1, boundary_y1, boundary_x2, boundary_y2`: 지시경계선 좌표 (선택사항)

### 6.3 처리 흐름
```
1. CSV 파일 로드 및 검증
   ↓
2. DXF 파일 로드
   ↓
3. 각 CSV 행에 대해:
   a. TEXT/MTEXT 엔티티 생성
   b. 지시화살표선 생성 (arrow 좌표가 있는 경우)
      - 주축선 생성
      - 화살촉 (2개 선분) 생성
   c. 지시경계선 생성 (boundary 좌표가 있는 경우)
   ↓
4. 수정된 DXF 파일 저장
   ↓
5. 추가 보고서 생성
```

### 6.4 엔티티 생성 규칙
```python
# TEXT 생성 설정
TEXT_CONFIG = {
    'height': 3.5,           # 기본 텍스트 높이 (mm)
    'style': 'Standard',     # 텍스트 스타일
    'rotation': 0,           # 회전 각도
}

# 화살표 생성 설정
ARROW_CONFIG = {
    'arrow_size': 2.5,       # 화살표 크기 (화살촉 길이, mm)
    'arrow_angle': 30.0,     # 화살촉 각도 (도)
    'line_weight': 0.25,     # 선 두께
}

def create_arrow(start_point, end_point, config):
    """
    화살표 생성 (주축선 + 화살촉)
    
    Args:
        start_point: 화살표 시작점
        end_point: 화살표 끝점 (화살촉 위치)
        config: ARROW_CONFIG
    
    Returns:
        [shaft_line, left_barb_line, right_barb_line]
    """
    # 주축선
    shaft = Line(start=start_point, end=end_point)
    
    # 화살표 방향 계산
    direction = direction_vector(shaft)
    angle_rad = math.atan2(direction[1], direction[0])
    
    # 화살촉 각도
    barb_angle_rad = math.radians(config['arrow_angle'])
    barb_length = config['arrow_size']
    
    # 왼쪽 화살촉
    left_angle = angle_rad + math.pi - barb_angle_rad
    left_barb_end = (
        end_point.x + barb_length * math.cos(left_angle),
        end_point.y + barb_length * math.sin(left_angle)
    )
    left_barb = Line(start=end_point, end=left_barb_end)
    
    # 오른쪽 화살촉
    right_angle = angle_rad + math.pi + barb_angle_rad
    right_barb_end = (
        end_point.x + barb_length * math.cos(right_angle),
        end_point.y + barb_length * math.sin(right_angle)
    )
    right_barb = Line(start=end_point, end=right_barb_end)
    
    return [shaft, left_barb, right_barb]
```

---

## 7. 개발 일정

### 7.1 Phase 1: chk_dimension.py (4주)
```
Week 1: 기본 DXF 파싱 및 레이어 분석
- DXF 파일 읽기
- 레이어 구조 추출
- 엔티티 분류

Week 2: 치수/주석 1차 식별 및 화살표 탐지
- TEXT/MTEXT/LEADER 추출
- 기본 정보 수집
- 화살표 패턴 탐지 알고리즘 구현

Week 3: 지시화살표선 탐지
- 화살표 기반 지시화살표선 식별
- 연결된 직선 탐지
- 텍스트 매칭

Week 4: 지시경계선 탐지 및 보고서 생성
- 지시경계선 알고리즘 구현
- Ex-leaders 탐지
- 분석 보고서 생성
- 테스트 및 디버깅
```

### 7.2 Phase 2: del_dimension.py (1주)
```
Week 5: 삭제 모듈 구현
- 엔티티 삭제 로직
- 화살표 구성 LINE 삭제
- output.dxf 생성
- 삭제 보고서
- 테스트
```

### 7.3 Phase 3: add_dimension.py (2주)
```
Week 6: CSV 파싱 및 엔티티 생성
- CSV 입력 처리
- TEXT/MTEXT 생성
- 화살표 생성 함수 구현

Week 7: 지시선 생성 및 통합 테스트
- 화살표선 생성
- 경계선 생성
- 전체 통합 테스트
```

---

## 8. 테스트 전략

### 8.1 단위 테스트
```python
# 각 주요 함수에 대한 단위 테스트
- 화살표 탐지 함수 (is_arrow_pattern)
- 거리 계산 함수 (distance, length)
- 각도 계산 함수 (angle_between)
- 내적 계산 함수 (dot_product)
- 텍스트 매칭 함수
- 지시경계선 판정 함수
- 화살표 생성 함수 (create_arrow)
```

### 8.2 통합 테스트
```
- 간단한 샘플 DXF (5~10개 엔티티, 2~3개 화살표)
- 중간 복잡도 DXF (50~100개 엔티티, 10~20개 화살표)
- 복잡한 실제 도면 DXF (500+ 엔티티, 50+ 화살표)
```

### 8.3 검증 항목
```
✓ 모든 TEXT/MTEXT가 정확히 추출되는가?
✓ 화살표 패턴이 정확히 인식되는가?
✓ 화살표 5가지 조건이 올바르게 검증되는가?
✓ 지시화살표선과 텍스트가 올바르게 매칭되는가?
✓ 지시경계선이 정확히 탐지되는가?
✓ 설정 파라미터 변경 시 결과가 적절히 변하는가?
✓ 삭제 후 복원이 정확한가? (del → add 조합)
✓ 생성된 화살표가 원본과 시각적으로 동일한가?
```

### 8.4 화살표 탐지 정확도 테스트
```python
# 화살표 탐지 정확도 측정
test_cases = [
    # (대칭 화살표, 각도 30도)
    {"type": "symmetric", "angle": 30, "expected": True},
    # (비대칭 화살표, 각도 25/35도)
    {"type": "asymmetric", "angle": (25, 35), "expected": True},
    # (너무 예각, 각도 10도)
    {"type": "too_sharp", "angle": 10, "expected": False},
    # (너무 둔각, 각도 60도)
    {"type": "too_obtuse", "angle": 60, "expected": False},
    # (화살촉 길이 부족, 1mm)
    {"type": "too_short", "length": 1.0, "expected": False},
]

# 목표: 정확도 90% 이상
```

---

## 9. 설정 파일 구조

### 9.1 config.json (통합 버전)
```json
{
  "arrow_detection": {
    "arrow_length_min": 2.0,
    "arrow_length_max": 5.0,
    "arrow_angle_min": 15.0,
    "arrow_angle_max": 45.0,
    "tip_point_tolerance": 0.1,
    "check_symmetry": false,
    "symmetry_tolerance": 5.0,
    "check_barb_ratio": false,
    "barb_ratio_min": 0.5,
    "barb_ratio_max": 2.0
  },
  "arrow_connected_line": {
    "max_gap": 3.0,
    "angle_tolerance": 5.0
  },
  "leader_arrow_matching": {
    "max_distance": 10.0
  },
  "leader_boundary_matching": {
    "max_distance_to_arrow": 5.0,
    "perpendicular_angle_min": 89.5,
    "perpendicular_angle_max": 90.5
  },
  "text_config": {
    "height": 3.5,
    "style": "Standard",
    "rotation": 0
  },
  "arrow_config": {
    "arrow_size": 2.5,
    "arrow_angle": 30.0,
    "line_weight": 0.25
  },
  "output": {
    "report_format": "text",
    "encoding": "utf-8"
  }
}
```

---

## 10. 위험 요소 및 대응 방안

### 10.1 기술적 위험

| 위험 요소 | 영향도 | 대응 방안 |
|----------|--------|----------|
| DXF 파일 형식 다양성 | 높음 | 다양한 버전의 샘플 파일로 테스트, ezdxf 라이브러리 활용 |
| 화살표 패턴 인식 오류 | 높음 | 5가지 조건 체계로 정확도 향상, 설정 가능한 파라미터 제공 |
| 대용량 파일 처리 성능 | 중간 | 공간 인덱싱, 청크 처리 |
| Ex-leaders 오탐/미탐 | 높음 | 화살표 기반 탐지로 정확도 향상, 다단계 검증 로직 |
| 부동소수점 오차 | 중간 | tolerance 파라미터로 오차 허용, 값 범위 제한 |

### 10.2 일정 위험
- 화살표 탐지 알고리즘이 예상보다 복잡할 경우: **대응 완료** (5가지 조건으로 명확히 정의)
- 다양한 DXF 파일 호환성 문제: 우선순위 높은 버전부터 지원
- 화살표 유형 다양성: Phase별로 단계적 구현 (Phase 1: LINE 기반만)

---

## 11. 향후 확장 가능성

### 11.1 Phase 4 (선택적)
```
- GUI 인터페이스 개발 (PyQt 또는 Tkinter)
- 시각적 검증 도구 (도면 미리보기 + 탐지 결과 오버레이)
- 배치 처리 기능 (여러 DXF 파일 동시 처리)
- 자동 오류 수정 기능 (AI 기반)
```

### 11.2 추가 기능 아이디어
```
- 치수/주석 스타일 일괄 변경
- 중복 치수 자동 탐지 및 제거
- 치수 정확성 검증 (도형과 치수 값 비교)
- DWG 파일 지원
- 채워진 화살표(SOLID) 지원
- 블록(INSERT) 화살표 지원
- 3D DXF 지원
```

---

## 12. 결론

본 기획서는 CAD-Work 프로젝트의 전체적인 방향성과 구현 세부사항을 정의합니다. 

**핵심 성공 요소:**
1. ✅ **명확한 화살표 정의**: 5가지 수학적 조건으로 구체화
2. ✅ **정확한 화살표 패턴 인식 알고리즘**: 단계별 탐지 로직
3. ✅ **유연한 설정 파라미터 시스템**: 다양한 CAD 도면 대응
4. ✅ **명확하고 상세한 분석 보고서**: 화살표 정보 포함
5. ✅ **다양한 DXF 파일에 대한 호환성**: ezdxf 라이브러리 활용

**주요 개선 사항 (v2.0):**
- 화살표의 구조적/수학적 정의 추가
- 화살표 판별 5가지 조건 명시
- 화살표 탐지 알고리즘 구체화
- 화살표 생성 함수 명세
- 설정 파라미터 확장

**다음 단계:**
기획서 검토 및 승인 후 chk_dimension.py 모듈부터 개발을 시작합니다.

---

**작성일:** 2025-10-19  
**버전:** 2.0 (화살표 정의 추가)  
**작성자:** CAD-Work 프로젝트 팀